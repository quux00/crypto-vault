package net.thornydev.crypto;

import java.security.InvalidKeyException;
import java.security.Key;
import java.security.KeyStore;
import java.security.KeyStore.SecretKeyEntry;
import java.security.KeyStore.PasswordProtection;
import java.security.NoSuchAlgorithmException;
import java.util.Random;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.CipherOutputStream;
import javax.crypto.CipherInputStream;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

/**
 * Creates Java Keystore which encrypts a key to encrypt/decrypt your
 * encrypted files. The keystore is encrypted with a password provided
 * by the user.  You do not know the actual key to encrypt/decrypt your
 * files, since it was generated by the KeyStore.SecretKeyEntry object.
 */
public class CryptoVault implements Vault {
  
  final String filename;
  final String keystoreName;
  final String password;
  
  static final String[] messages = new String[]{"message 1", 
    "message 2 is a really, really long message, don't you know. EOL.",
    "name-rank-serial-number"};

  
  public static void main(String[] args) throws Exception {
    CryptoVault cv = new CryptoVault("my.cryptovault", "vault-keystore", "shadowFax");
    cv.initializeVault();
    
    String msg = messages[ new Random().nextInt(messages.length) ];
    
    cv.encryptToVault(msg);
    System.out.println(cv.decryptFromVault());
    
    System.out.println("Done");
  }

  
  /**
   * pure (static) function
   * call this only after having initialized the key store
   * @param v
   * @return the SecretKey in the KeyStore j
   */
  public static Key vaultKey(Vault v) {
    char[] passwd = v.getPassword().toCharArray();
    
    FileInputStream fis = null;
    try {
      fis = new FileInputStream(v.getKeystoreName());
      KeyStore ks = KeyStore.getInstance("JCEKS");
      ks.load(fis, passwd);
      return ks.getKey("vault-key", passwd);
      
    } catch (Exception e) {
      System.err.println(e.getMessage());
      return null;
    } finally {
      try {
        if (fis != null) fis.close();
      } catch (Exception e) {}
    }
  }
  
  // the CryptoVault type
  
  public CryptoVault(String fname, String kstoreName, String passw) {
    this.filename = fname;
    this.keystoreName = kstoreName;
    this.password = passw;
  }
  
  /**
   * This creates / writes the keystore to file.
   * This is NOT the encrypted message file - this stores
   * an encrypted secret key
   */
  @Override
  public void initializeVault() {
    char[] passwd = password.toCharArray();
    FileOutputStream fos = null;
    try {
      SecretKey skey = KeyGenerator.getInstance("AES").generateKey();
      KeyStore ks = KeyStore.getInstance("JCEKS");
      // load null means: create an empty keystore (in memory)
      ks.load(null, passwd);
      // add a password protected secret key "entry" to the keystore
      ks.setEntry("vault-key", new KeyStore.SecretKeyEntry(skey), 
          new KeyStore.PasswordProtection(passwd));

      // now write the keystore to file
      fos = new FileOutputStream(this.getKeystoreName());
      ks.store(fos, passwd);
      
    } catch (Exception e) {
      throw new RuntimeException(e);
    } finally {
      if (fos != null) {
        try {
          fos.close();
        }
        catch (IOException e) {
          e.printStackTrace();
        }
      }
    }
  }

  
  /**
   * @return CipherOutputStream ciphertext to write to an encrypted file
   */
  @Override
  public OutputStream vaultOutputStream() {
    try {
      Cipher cipher = Cipher.getInstance("AES");
      cipher.init(Cipher.ENCRYPT_MODE, vaultKey(this));
      return new CipherOutputStream(new FileOutputStream(this.getFilename()), cipher);
    }
    catch (NoSuchAlgorithmException e) {
      e.printStackTrace();
    }
    catch (NoSuchPaddingException e) {
      e.printStackTrace();
    }
    catch (InvalidKeyException e) {
      e.printStackTrace();
    }
    catch (FileNotFoundException e) {
      e.printStackTrace();
    }
    
    return null;
  }

  @Override
  public InputStream vaultInputStream() {
    try {
      Cipher cipher = Cipher.getInstance("AES");
      cipher.init(Cipher.DECRYPT_MODE, vaultKey(this));
      return new
        CipherInputStream(new FileInputStream(this.getFilename()),
                          cipher);
    }
    catch (Exception e) {
      e.printStackTrace();
    }
    return null;
  }

  @Override
  public void encryptToVault(String msg) {
    try {
      CipherOutputStream cos = (CipherOutputStream)this.vaultOutputStream();
      cos.write(msg.getBytes());
      cos.close();
    }
    catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  @Override
  public String decryptFromVault() {
    try {
      StringBuilder sb = new StringBuilder();
      InputStream is = this.vaultInputStream();
      byte[] b = new byte[4];
      while (true) {
        int n = is.read(b);
        if (n < 0) break;
        sb.append(new String(b, 0, n));
      }
      return sb.toString();
    }
    catch (IOException e) {
      throw new RuntimeException(e);
    }
  }  

  
  @Override
  public String getPassword() {
    return password;
  }

  @Override
  public String getFilename() {
    return filename;
  }

  @Override
  public String getKeystoreName() {
    return keystoreName;
  }

}
